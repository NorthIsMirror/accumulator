#
# Started from zle
# Displays zz-list with manual for the first word on the line
# Pastes output of zz-list into current cursor position
#

setopt localoptions typesetsilent

autoload zz-process-buffer zz-usetty-wrapper zz-list zz-list-input zz-list-draw

local curcontext=":zle:$WIDGET"
local MATCH MBEGIN MEND i

# Prepare output variables for zz-process-buffer
local ZZ_PB_WORDS="" ZZ_PB_WORDS_BEGINNINGS="" ZZ_PB_SPACES=""
local ZZ_PB_SELECTED_WORD="" ZZ_PB_LEFT="" ZZ_PB_RIGHT=""

# Process current buffer
zz-process-buffer "$BUFFER"

# Select command for man
integer i size="${#ZZ_PB_WORDS}"
local cmd=""
for (( i=1; i<=size; i++ )); do
    [ "$cmd" = "" ] && cmd="${ZZ_PB_WORDS[i]}"
    [ "$i" = "$ZZ_PB_SELECTED_WORD" ] && break
    [ "$ZZ_PB_WORDS[i]" = ";" ] && cmd=""
done

local ZZLIST_WRAPPER_BIT=""
zz-usetty-wrapper zz-list-wrapper ${(f)"$( man "$cmd" | col -b )"}

#
# Rebuilding buffer
#

integer pos="$CURSOR"
integer size="${#ZZ_PB_WORDS}"
integer newcursor
buf=""

zle kill-buffer

integer i j
for (( i=1; i<=size; i++ )); do
    # Check if we're at (i.e. directly at or after,
    # when after are just spaces) current word
    if [ "$i" = "$ZZ_PB_SELECTED_WORD" ]; then
        # Check if we're at the word itself,
        # or at some distance after it
        if (( pos > (ZZ_PB_WORDS_BEGINNINGS[i] + ${#ZZ_PB_WORDS[i]} - 1) )); then
            # We need to introduce new word
            # First move all words and spaces forward
            for (( j=size; j>=i+1; j-- )); do
                ZZ_PB_WORDS[j+1]="${ZZ_PB_WORDS[j]}"
                ZZ_PB_SPACES[j+1]="${ZZ_PB_SPACES[j]}"
                ZZ_PB_WORDS_BEGINNINGS[j+1]="${ZZ_PB_WORDS_BEGINNINGS[j]}"
            done
            size+=1

            # New word is introduced at position i+1, after current word
            # It doesn't have word beginnings and spaces assigned
            # It has to take spaces from word next to it, i+2
            ZZ_PB_WORDS[i+1]="$ZZLIST_WRAPPER_BIT"
            ZZ_PB_WORDS_BEGINNINGS[i+1]="$(( pos + 1 ))"

            # Now split spaces
            # cursor_spaces: spaces from current word to the cursor
            integer cursor_spaces=$(( pos - ZZ_PB_WORDS_BEGINNINGS[i] - ${#ZZ_PB_WORDS[i]} + 1 ))
            # take that from spaces of word "next" in: current NEW next
            integer after_spaces=$(( ZZ_PB_SPACES[i+2] - cursor_spaces ))
            local empty=""
            ZZ_PB_SPACES[i+1]="${(l:cursor_spaces:: :)empty}"
            ZZ_PB_SPACES[i+2]="${(l:after_spaces:: :)empty}"

            # Cursor will be at end of newly added word
            newcursor=$(( ZZ_PB_WORDS_BEGINNINGS[i+1] + ${#ZZ_PB_WORDS[i+1]} - 1 ))

        else
            ZZ_PB_WORDS[i]="$ZZLIST_WRAPPER_BIT"

            # Cursor will be at end of newly substituted word
            newcursor=$(( ZZ_PB_WORDS_BEGINNINGS[i] + ${#ZZ_PB_WORDS[i]} - 1 ))

            # Update word beginnings of following words – skipped
        fi
    fi
    buf+="$ZZ_PB_SPACES[i]$ZZ_PB_WORDS[i]"
done

# Append final white spaces
buf+="$ZZ_PB_SPACES[i]"
BUFFER="$buf"
CURSOR="$newcursor"

zle redisplay

# vim:ft=zsh
